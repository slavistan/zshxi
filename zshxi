#!/usr/bin/env zsh

if [[ "$1" == -h ]] || [[ "$1" == --help ]]; then
	cat <<EOF
Spawn terminals with interactive zsh sessions and autorun commands. Commands
are read from file or from stdin and are automatically added to the shell's
history.

Usage: zshxi [-c FILE] [-b] [-s] [TERMPREFIX]...

    -c: Path to file containing commands. Reads from stdin by default.
    -b: History contains a single batch command. Line-by-line by default.
    -s: Shell only. No terminal is spawned and TERMPREFIX is ignored.

    TERMPREFIX is the terminal-specific startup command-line prefix. Uses
    Uses '\$TERMINAL -e' by default which is compatible with most terminals.
    Note that if \$TERMINAL is not defined, you must explicitly specify your
    terminal.

Examples:

    # use \$TERMINAL envvar
    zshxi <<< date

    # use gnome-terminal
    zshxi gnome-terminal -- <<< nvim

    # use alacritty and read commands from file
    zshxi -c /file/to/commands alacritty -e

See 'https://github.com/slavistan/zshxi' for more information.
EOF
exit
fi

# Parse command line.
zparseopts -F -D -- c:=opt_commands b:=histbatch s=shellonly
commands_file="${opt_commands[2]:--}"
[[ -z "$@" ]] &&
	term_prefix=( "$TERMINAL" "-e" ) ||
	term_prefix=( "${@}" )

# set up tempdir and create file to exchange startup instructions.
basedir="${TMPDIR:-${XDG_RUNTIME_DIR:-/tmp}}/zshxi"
mkdir -p "$basedir"
tmpdir="${ZSHXI_TMPDIR:-$(mktemp -d "$basedir/zshxi.XXXXXXXXXX")}"
extra_zshrc="$tmpdir/extra.zshrc"

# Build eval string depending on how the history should be created.
# Empty lines are kept for batch mode only.
if [[ ! "${histbatch}" ]]; then
	history_eval='awk NF "'$extra_zshrc'" | while read line; do
		builtin print -s "$line"
	done'
else
	history_eval='builtin print -s "$(cat "'$extra_zshrc'")"'
fi

# Build eval string to clean up tempdir. If ZSHXI_TMPDIR is defined it will be
# used as the temporary directory and no cleanup shall be performed. Useful for
# debugging.
if [[ ! ${ZSHXI_TMPDIR+x} ]]; then
	cleanup_eval="builtin command rm -rf -- '${(q)tmpdir}'"
fi

# Generate rc files depending on what kind of shell we are.
for rc in .zshenv .zprofile .zshrc .zlogin; do
	>$tmpdir/$rc <<<'{
ZDOTDIR="$_zshi_zdotdir"
if [[ -f "$ZDOTDIR/'$rc'" && -r "$ZDOTDIR/'$rc'" ]]; then
builtin source -- "$ZDOTDIR/'$rc'"
fi
} always {
if [[ -o no_rcs ||
		-o login && "'$rc'" == .zlogin ||
		-o no_login && "'$rc'" == .zshrc ||
		-o no_login && -o no_interactive && '$rc' == .zshenv ]]; then
	builtin unset _zshi_zdotdir
	builtin source "'$extra_zshrc'"
	'$history_eval'
	'$cleanup_eval'
else
	_zshi_zdotdir=${ZDOTDIR:-~}
	ZDOTDIR='${(q)tmpdir}'
fi
}'
done

# write commands to exchange file and run everything.
cat "$commands_file" >"$extra_zshrc"
if [[ "${shellonly}" ]]; then
	_zshi_zdotdir=${ZDOTDIR:-~} ZDOTDIR=$tmpdir exec zsh
else
	_zshi_zdotdir=${ZDOTDIR:-~} ZDOTDIR=$tmpdir nohup ${term_prefix} zsh >/dev/null 2>&1 &!
fi

# MAYBE: Clean up tempdir if startup of terminal fails.
#        Cleanup is done during zsh startup after extra.zsh has been sourced.
#        If, however, the invocation of the terminal fails (e.g. by syntax
#        errors) there won't be any cleanup. Try `zshxi faketerm <<<date`.
#        Find a way to clean up the tmpdir:
#        - without messing up the pstree
#        - leaving the new terminal truly detached
#        - without introducing arbitrary timers.
# MAYBE: Create a man page.
