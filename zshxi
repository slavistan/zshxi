#!/usr/bin/env zsh

set -e

if [[ "$1" == -h ]] || [[ "$1" == --help ]]; then
	cat <<EOF
Spawn terminals with interactive zsh sessions and autorun commands. Commands
are read from file or from stdin and are automatically added to the shell's
history.

Usage: zshxi [-c FILE] [TERMPREFIX]...

    -c: Path to file containing commands. Reads from stdin by default.

    TERMPREFIX is the terminal-specific startup command-line prefix. Uses
    Uses '\$TERMINAL -e' by default which is compatible with most terminals.
    Note that if \$TERMINAL is not defined, you must explicitly specify your
    terminal.

Examples:

    # use \$TERMINAL envvar
    zshxi <<< date

    # use gnome-terminal
    zshxi gnome-terminal -- <<< nvim

    # use alacritty and read commands from file
    zshxi -c /file/containing/commands alacritty -e

See 'https://github.com/slavistan/zshxi' for more information.
EOF
exit
fi

# Parse command line.
zparseopts -F -D -- c:=opt_commands
commands_file="${opt_commands[2]:--}"
if [[ -z "$@" ]]; then
	if [[ -z "$TERMINAL" ]]; then
		echo "\$TERMINAL is undefined and no TERMPREFIX was provided. Abort." >&2
		exit 1
	fi
	term_prefix=( "$TERMINAL" "-e" )
else
	term_prefix=( "${@}" )
fi

# Perform a basic sanity check of the terminal startup command.
if [[ ! -x "$(command -v "${term_prefix[1]}")" ]]; then
	echo "'${term_prefix[1]}' is not in \$PATH or is not executable. Abort." >&2
	exit 1
fi

# Set up tmpdir and define cleanup instructions. Cleanup is performed at the
# very end, after shell initialization and execution of the user instructions
# has finished. If defined, ZSHXI_TMPDIR will be used as the temporary
# directory and cleanup will be skipped. Use this for debugging to preserve all
# auxilliary files. ZSHXI_TMPDIR will be created, if it doesn't exist.
if [[ -z "$ZSHXI_TMPDIR" ]]; then
	basedir="${XDG_RUNTIME_DIR:-${TMPDIR:-/tmp}}/zshxi"
	mkdir -p "$basedir"
	tmpdir="$(mktemp -d "$basedir/zshxi.XXXXXXXXXX")"
	cleanup_instructions="builtin command rm -rf -- '${(q)tmpdir}'"
else
	tmpdir="$(realpath "$ZSHXI_TMPDIR")"
	mkdir -p "$ZSHXI_TMPDIR"
	cleanup_instructions=
fi

# Clean up if zshxi is terminated prematurely.
cleanup() {
	rm -r "${(q)tmpdir}"
	exit "${1:-0}"
}
trap cleanup INT HUP QUIT TERM

# Capture user instructions to be executed after regular shell initialization.
# We make use of cat's sugar of reading from stdin when the input file is '-'.
user_instructions="$(cat "$commands_file")"

# Generate rc files for every kind of shell. Embed user instructions and
# configure the DEBUG trap to add commands to history and to print them before
# execution.
for rc in .zshrc; do
	>"$tmpdir/$rc" <<<'
ZDOTDIR="$_zshi_zdotdir"
source "$ZDOTDIR/'$rc'";
unset _zshi_zdotdir
zshxi_cleanup() {
	'$cleanup_instructions'
	trap - INT HUP QUIT TERM
	unfunction zshxi_cleanup
}
trap zshxi_cleanup INT HUP QUIT TERM
TRAPDEBUG() {
	if [[ "$ZSH_DEBUG_CMD" != "trap - DEBUG" ]]; then
		print -rP -- "${PS1}$ZSH_DEBUG_CMD"
		print -rs -- "$ZSH_DEBUG_CMD"
	fi
}
'$user_instructions'
trap - DEBUG
zshxi_cleanup
'
done

_zshi_zdotdir="${ZDOTDIR:-~}" ZDOTDIR="$tmpdir" ${term_prefix} zsh >/dev/null 2>&1 &
# WONTFIX: Cleanup is not performed if terminal startup fails
#          If zsh is not run in a terminal no cleanup is triggered. Try
#            zshxi date <<<"echo hi"
#          and notice the auxilliary files not being deleted. This cannot be
#          fixed without either messing up the process tree by adding watcher
#          processes or by introducing arbitrary timers.

# FIXME: Aliases are expanded.
#        Aliases (defined in either the default zshrc or the user commands) are
#        expanded, violating the "as if you had type the command" policy of
#        this project.
#
# FIXME: User functions display the individual commands.
#        Instead of treating user functions as a single command, their contents
#        are spilled into the history, command-by-command.
#
# FIXME: Syntax errors in user commands cause mayhem
#        Try `zshxi <<<"echo \"hi"`.
#
# FIXME: Trap settings are overwritten in zshxi_cleanup.
#        The user may have defined traps which would get overwritten by us.
#        Instead, trap settings should be saved and loaded.
